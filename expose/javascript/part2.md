1. error; i out of scope
2. the value 150 will be printed to the console (the final value of discountedPrice; (prices[prices.length - 1] * (1 - discount)))
3. the value 150 will be printed (the final value of finalPrice; Math.round(((prices[prices.length - 1] * (1 - discount)) * 100)/100))
4. the function returns an array called discounted = [50, 100, 150] (an array of length (prices.length) where discounted[i] is equal to the rounded, discounted corresponding value in the prices array) (discounted[i] = Math.round(((prices[i] * (1 - discount)) * 100)/100)) from 0 <= i < prices.length)
5. an error; at line 12 the variable i is out of scope/doesn't exist
6. an error; at line 13 the variable discountedPrice is out of scope/doesn't exist
7. the value 150 will be printed (the final value of finalPrice; Math.round(((prices[prices.length - 1] * (1 - discount)) * 100)/100))
8. the function returns an array called discounted = [50, 100, 150]
9. error; i out of scope
10. 3 is printed (prices.length = 3)
11. error; discounted cannot be modified from its initial declaration as a const empty array
12. A. student.name
    B. student['Grad Year']  
    C. student.greeting()  
    D. student['Favorite Teacher'].name  
    E. student.courseLoad[0]  
13. A. 32: + interpreted as concatenation  
    B. 1: '3' cast to an integer as - doesn't have a string equivalent  
    C. 3: null has value 0  
    D. 3null: null gets cast to a string as + is interpreted as concatenation, not addition  
    E. 4: true evaluates to 1  
    F. 0: false, null both evaluate to 0  
    G. 3undefined: undefined gets cast to a string as + is interpreted as concatenation, not addition  
    H. NaN: - operation doesn't exist for chars/strings  
14. A. True: '2' evaluates to 2 under > operation; 2>1 == True  
    B. False: '12' has lesser lexicographical value as a string than '2'  
    C. True: '2' evaluates to 2; 2==2 is true  
    D. False; 2 and '2' have differing types  
    E. False; true evaluates to 1, 1 != 2.  
    F. True; Boolean(2) is of type boolean and evaluates to true which evaluates to 1; true is also of type boolean and evaluates to true = 1; 1 == 1 is true and same typing.  
15. == evaluates whether the expressions on either side evaluate to the same value and returns true or false depending; === only returns true if the expressions on either side evaluate to the same value AND have strictly the same type.
16. in separate file 
17. The array newArr = [2,4,6] will be returned; each of values 1, 2, 3 are passed into the callback function which doubles them and then stores them in newArr in the same respective position.
18. in separate file 
19. 1
    4
    3
    2
